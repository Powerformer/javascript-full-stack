数据流动如下：

```javascript
functionValue <-- unary <-- adder <-- 3
```



```javascript
function words(str) {
    return String( str )
        .toLowerCase()
        .split( /\s|\b/ )
        .filter( function alpha(v){
            return /^[\w]+$/.test( v );
        } );
}

function unique(list) {
    var uniqList = [];

    for (let i = 0; i < list.length; i++) {
        // value not yet in the new list?
        if (uniqList.indexOf( list[i] ) === -1 ) {
            uniqList.push( list[i] );
        }
    }

    return uniqList;
}
```

change:

```javascript
var wordsUsed = unique( words( text ) );
```

太过笨重：改变并封装：

```javascript
function uniqueWords(str) {
    return unique( words( str ) );
}
```

数据流动还是原来的样子：

```javascript
wordsUsed <-- unique <-- words <-- text
```

不够通用，还是很笨重，那么我们继续进行改变和封装：

```javascript
function compose2(fn2, fn1) {
  return function composed(origValue) {
    return fn2(fn1(origValue));
  };
}
```

我们能够构造一个由 `compose(..)` 自身组成的右偏函数应用，通过提前定义好第二和第三参数（`unique(..)` 和 `words(..)`）；我们把它称作 `filterWords(..)`（如下）。

然后，我们能够通过多次调用 `filterWords(..)` 来完成组合，但是每次的第一参数却各不相同。

```javascript 
function skipLongWors(list) { /* */ }

var filterWords = partialRight(compose, unique, words);

var biggerWords = filterWords(skipShortWords);
var shorterWords = filterWords(skipLongWords);

biggerWords(text);
// ["compose","functions","together","output","first",
// "function","input","second"]

shorterWords(text);
// ["to","two","pass","the","of","call","as"]
```

我们通过使用partialRight能先做一步特定的指定，然后以不同后期步骤创建特定的变体。这是函数式编程中最强大的手段之一。

### 不同的实现

我们将稍后在文中查看 `reduce(..)` 实用函数的细节，但现在，只需了解它将一个列表（数组）简化为一个单一的有限值。看起来像是一个很棒的循环体。

实现递归的好处是更加概念化。通过递归的方式进行重复的动作反而更易懂。