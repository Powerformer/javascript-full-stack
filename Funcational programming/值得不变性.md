## 原始值的不可变性

原始数据类型（`number`、`string`、`boolean`、`null` 和 `undefined`）本身就是不可变的；无论如何你都没办法改变它们。

思考下面的代码：

```javascript
var x = 2;

x.length = 4;

x;                // 2
x.length;        // undefined
```

但是 JS 允许 `x.length = 4` 这条语句正常执行的事实着实令人困惑。如果这种现象真的无缘无故出现，那么代码的阅读者无疑会摸不着头脑。好消息是，如果你使用了严格模式（`"use strict";`），那么这条语句就会抛出异常了。

那么如果尝试改变那些明确被包装成对象的值呢？

```javascript
var x = new Number( 2 );

// 没问题
x.length = 4;
```

这段代码中的 `x` 保存了一个对象的引用，因此可以正常地添加或修改自定义属性。

字符串的确是不可变的：

```javascript
var s = "hello";

s[1];                // "e"

s[1] = "E";
s.length = 10;

s;                    // "hello"
```



有趣的是，即便是包装后的 `String` 对象，其值也会（在大部分情况下）表现的和非包装字符串一样 —— 在严格模式下如果改变已存在的属性，就会抛出异常：

```javascript
"use strict";

var s = new String( "hello" );

s[1] = "E";            // error
s.length = 10;        // error

s[42] = "?";        // OK

s;                    // "hello"
```

## 从值到值

值的不可变性是指当需要改变程序中的状态时，我们不能改变已存在的数据，而是必须创建和跟踪一个新的数据。

例如：

```javascript
function addValue(arr) {
    var newArr = [ ...arr, 4 ];
    return newArr;
}

addValue( [1,2,3] );    // [1,2,3,4]
```

注意我们没有改变数组 `arr` 的引用，而是创建了一个新的数组（`newArr`），这个新数组包含数组 `arr` 中已存在的值，并且新增了一个新值 `4`。

通过规范我们的值并把它视为不可变的，我们大幅减少了程序错误，使我们的程序更易于阅读和推导，最终使程序更加可信赖。

`arr` 所引用的数组是可变的，只是我们选择不去改变他，我们实践了值不可变的这一精神

### 消除本地影响

对于防止数据变化负面影响，稍后我们会讨论另一种策略。

## 重新赋值

在进入下一个段落之前先思考一个问题 —— 你如何描述“常量”？

对于常量，我们可以给出一个简洁的定义：一个无法进行重新赋值（reassignment）的变量。

无论常量承载何值，该变量都不能使用其他的值被进行重新赋值。但它与值的本质无关。

从这方面来讲，我认为 `const` 反而增加了函数式编程的困难度。我的结论是：`const` 并不是那么有用。它不仅造成了不必要的混乱，也以一种很不方便的形式限制了我们。我只用 `const` 来声明简单的常量，例如：

```javascript
const PI = 3.141592;
```

`3.141592` 这个值本身就已经是不可变的，并且我也清楚地表示说“`PI` 标识符将始终被用于代表这个字面量的占位符”。对我来说，这才是 `const` 所擅长的。坦白讲，我在编码时并不会使用很多这样的声明。

## 性能

思考下面的 `specialArray` 示例，这次使用 `Immutable.List`：

```javascript
var state = Immutable.List.of( 1, 2, 3, 4 );

var newState = state.set( 42, "meaning of life" );

state === newState;                    // false

state.get( 2 );                        // 3
state.get( 42 );                    // undefined

newState.get( 2 );                    // 3
newState.get( 42 );                    // "meaning of life"

newState.toArray().slice( 1, 3 );    // [2,3]
```

像 Immutable.js 这样强大的库一般会采用非常成熟的性能优化。如果不使用库而是手动去处理那些细枝末节，开发的难度会相当大。

当改变值这样的场景出现的较少且不用太关心性能时，我推荐使用更轻量级的解决方案，例如我们之前提到过的内置的 `Object.freeze(..)`。

## 以不可变的眼光看待数据

**应当总是将 user 看做不可变的值**，这样我们就没必要知道数据从哪里来，也没必要担心数据改变会引发潜在问题。

JavaScript 中内置的数组方法就是一些很好的例子，例如 `concat(..)` 和 `slice(..)` 等：

```javascript
var arr = [1,2,3,4,5];

var arr2 = arr.concat( 6 );

arr;                    // [1,2,3,4,5]
arr2;                    // [1,2,3,4,5,6]

var arr3 = arr2.slice( 1 );

arr2;                    // [1,2,3,4,5,6]
arr3;                    // [2,3,4,5,6]
```

其他一些将参数看做不可变数据且返回新数组的原型方法还有：`map(..)` 和 `filter(..)`等。`reduce(..)` / `reduceRight(..)` 方法也会尽量避免改变参数，尽管它们并不默认返回新数组。

有些人建议禁止使用这些不纯的方法，但我不这么认为。因为一些性能面的原因，某些场景下你仍然可能会用到它们。不过你也应当注意，如果一个数组没有被本地化在当前函数的作用域内，那么不应当使用这些方法，避免它们所产生的副作用影响到代码的其他部分。

不论一个数据是否是可变的，永远将他们看做不可变。遵守这样的约定，你程序的可读性和可信赖度将会大大提升。

