## 达成共识

先确定一点，当我们谈及闭包和对象我们都达成了共识。我们显然是在 JavaScript 如何处理这两种机制的上下文中进行讨论的，并且特指的是讨论简单函数闭包（见第 2 章的“保持作用域”）和简单对象（键值对的集合）。

## 相像

闭包和对象之间的关系可能不是那么明显。让我们先来探究它们之间的相似点。

为了给这次讨论一个基调，让我简述两件事：

1. 一个没有闭包的编程语言可以用对象来模拟闭包。
2. 一个没有对象的编程语言可以用闭包来模拟对象。

换句话说，我们可以认为闭包和对象是一样东西的两种表达方式。



## 同根异枝

#### 结构可变性

从概念上讲，闭包的结构不是可变的。

换而言之，你永远不能从闭包添加或移除状态。闭包是一个表示对象在哪里声明的特性（被固定在编写／编译时间），并且不受任何条件的影响 —— 当然假设你使用严格模式并且／或者没有使用作弊手段例如 `eval(..)`。

但是，对象默认是完全可变的，你可以自由的添加或者移除（`delete`）一个对象的属性／索引，只要对象没有被冻结（`Object.freeze(..)`）

闭包是一个追踪所有状态的机制

### 私有

当对比分析闭包和对象时可能你思考的第一个区分点就是闭包通过词法作用域提供“私有”状态，而对象将一切做为公共属性暴露。这种私有有一个精致的名字：信息隐藏。

#### 可见性

对象状态数据的可见性让我们能更直接地使用它，而闭包遮掩状态让我们更艰难地处理它。

#### 变更控制

如果词法变量被隐藏在一个闭包中，只有闭包内部的代码才能自由的重新赋值，在外部修改 `x` 是不可能的。

正如我们在第 6 章看到的，提升代码可读性的唯一真相就是减少表面掩盖，读者必须可以预见到每一个给定变量的行为。

作用域（例如闭包）通常应该尽可能小，这意味着重新赋值只会影响少许代码。在上面的 `outer()`中，我们可以快速地检查到没有一行代码重设了 x，至此（x 的）所有意图和目的表现地像一个常量。

换而言之，`xPublic.x` 是一个公开属性，程序的任何部分都能引用 `xPublic` ，默认有重设 `xPublic.x` 到别的值的能力。这会让很多行代码需要被考虑。

在我想允许重新赋值但是在表层限制的地方，闭包比起对象更方便和灵活。在我不想重新赋值的地方，一个冻结的对象比起重复 `const` 声明在我所有的函数中更方便一些。

### 状态拷贝

正如我们在第 6 章学习的，防止副作用侵蚀代码可预测性的最好方法之一是确保我们将所有状态值视为不可变的，无论他们是否真的可变（冻结）与否。

在表示需要拷贝的状态时，对象具有一个更明显的优势。

### 性能

从实现的角度看，对象有一个比闭包有利的原因，那就是 JavaScript 对象通常在内存和甚至计算角度是更加轻量的。

但是需要小心这个普遍的断言：有很多东西可以用来处理对象，这会抹除你从无视闭包转向对象状态追踪获得的任何性能增益

